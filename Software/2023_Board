
#include <Adafruit_Sensor_Calibration.h>
#include <Adafruit_AHRS.h>
#include <QTRSensors.h>
#include <Adafruit_VL53L0X.h>
#include <Ultrasonic.h>
#include <GyverOLED.h>
GyverOLED<SSH1106_128x64> oled;

#define enA 2 
#define in1 46 
#define in2 48 
#define enB 3 
#define in3 50 
#define in4 52 
#define enC 7 //Skipped port 4 on motor Arduino, does not work 
#define in5 36 
#define in6 34 
#define enD 5 
#define in7 32 
#define in8 30 

void Update_sensors(); 
void motor_stop();
void robot_fwd(bool, int); 
void robot_rev(bool, int); 
void motors_turn_right(); 
void crab_walk_left(int); 

bool FrontFlag, BackFlag, RightFlag; 
float LeftUltra, FrontUltra, BackUltra, RightUltra; 

uint32_t timestamp;
uint32_t u32_currentMillis = 0;
uint32_t u32_positionMillis = 0;
uint32_t u32_orientationMillis = 0;
uint32_t u32_locationMillis = 0;
uint32_t u32_objectDetectionMillis = 0;

Adafruit_VL53L0X sensor1; //CHANGE
Adafruit_VL53L0X sensor2; //CHANGE
Adafruit_VL53L0X sensor3; //CHANGE
Adafruit_VL53L0X sensor4; //CHANGE
Adafruit_VL53L0X sensor5; //CHANGE
Adafruit_VL53L0X sensor6; //CHANGE
Adafruit_VL53L0X sensor7; //CHANGE
Adafruit_VL53L0X sensor8; //CHANGE

String start = "<";
String end = ">";
String c = ",";

typedef struct {
  Adafruit_VL53L0X *psensor; // pointer to object
  TwoWire *pwire;
  int id;            // IIC id number for the sensor
  int shutdown_pin;  // which pin for shutdown;
  int interrupt_pin; // which pin to use for interrupts.
  Adafruit_VL53L0X::VL53L0X_Sense_config_t sensor_config; // options for how to use the sensor
  uint16_t range;        // range value used in continuous mode stuff.
  uint8_t sensor_status; // status from last ranging in continuous.
} sensorList_t;


// Setup for 8 sensors by defining information for each sensor in a 'sensors' array. Include
// a separate line of information for each sensor
sensorList_t sensors[] = {
  // For 'sensor1', define the IIC accress as hexadecimal value 0x30. Assign digital pin #4 to this 
  // sensor's XSHUT pin (shut-down pin). Assign digital pin #5 to the sensor's INTERRUPT pin.
  {&sensor1, &Wire, 0x30, 38, 5, Adafruit_VL53L0X::VL53L0X_SENSE_DEFAULT, 0, 0},

  // For 'sensor2', define the IIC accress as hexadecimal value 0x31. Assign digital pin #6 to this 
  // sensor's XSHUT pin (shut-down pin). Assign digital pin #7 to the sensor's INTERRUPT pin.
  {&sensor2, &Wire, 0x31, 6, 7, Adafruit_VL53L0X::VL53L0X_SENSE_DEFAULT, 0, 0},

  
  // For 'sensor3', define the IIC accress as hexadecimal value 0x32. Assign digital pin #22 to this 
  // sensor's XSHUT pin (shut-down pin). Assign digital pin #23 to the sensor's INTERRUPT pin.
  {&sensor3, &Wire, 0x32, 40, 3, Adafruit_VL53L0X::VL53L0X_SENSE_DEFAULT, 0, 0},
  
  // For 'sensor4', define the IIC accress as hexadecimal value 0x33. Assign digital pin #24 to this 
  // sensor's XSHUT pin (shut-down pin). Assign digital pin #25 to the sensor's INTERRUPT pin.
  {&sensor4, &Wire, 0x33, 29, 30, Adafruit_VL53L0X::VL53L0X_SENSE_DEFAULT, 0, 0},

  // For 'sensor5', define the IIC accress as hexadecimal value 0x34. Assign digital pin #26 to this 
  // sensor's XSHUT pin (shut-down pin). Assign digital pin #27 to the sensor's INTERRUPT pin.
  {&sensor5, &Wire, 0x34, 31, 32, Adafruit_VL53L0X::VL53L0X_SENSE_DEFAULT, 0, 0},

  // For 'sensor6', define the IIC accress as hexadecimal value 0x35. Assign digital pin #28 to this 
  // sensor's XSHUT pin (shut-down pin). Assign digital pin #29 to the sensor's INTERRUPT pin.
  {&sensor6, &Wire, 0x35, 33, 34, Adafruit_VL53L0X::VL53L0X_SENSE_DEFAULT, 0, 0},

  // For 'sensor7', define the IIC accress as hexadecimal value 0x36. Assign digital pin #30 to this 
  // sensor's XSHUT pin (shut-down pin). Assign digital pin #31 to the sensor's INTERRUPT pin.
  {&sensor7, &Wire, 0x36, 35, 36, Adafruit_VL53L0X::VL53L0X_SENSE_DEFAULT, 0, 0},
  
  // For 'sensor8', define the IIC accress as hexadecimal value 0x37. Assign digital pin #32 to this 
  // sensor's XSHUT pin (shut-down pin). Assign digital pin #25 to the sensor's INTERRUPT pin.
  {&sensor8, &Wire, 0x37, 37, 38, Adafruit_VL53L0X::VL53L0X_SENSE_DEFAULT, 0, 0}
  
};
const int COUNT_SENSORS = sizeof(sensors) / sizeof(sensors[0]); //CHANGE
uint16_t objectDetectRanges_mm[COUNT_SENSORS]; //CHANGE
struct Packet{
  uint32_t locationFront; //CHANGE
  uint32_t locationBack; //CHANGE
  uint32_t locationRight; //CHANGE
  uint32_t locationLeft; //CHANGE
  uint16_t objectDetectionSensors[8]; //CHANGE
};

Packet packet;
void run_Location();
void run_ObjectDetection();
void setup_ObjectDetection();
void initialize_ObjDetectSensors();

Ultrasonic ultrasonicFront(8); //CHANGE
Ultrasonic ultrasonicBack(9); //CHANGE
Ultrasonic ultrasonicRight(10); //CHANGE
Ultrasonic ultrasonicLeft(11); //CHANGE


void setup() {
  Serial.begin(115200);
  delay(200);
  oled.init();             
  oled.clear();
  setup_ObjectDetection();
  timestamp = millis();
  
  Wire.begin();
   pinMode(in1, OUTPUT); //Motor 1 
  pinMode(in2, OUTPUT); 
  pinMode(in3, OUTPUT); //Motor 2 
  pinMode(in4, OUTPUT); 
  pinMode(in5, OUTPUT); //Motor 3 
  pinMode(in6, OUTPUT); 
  pinMode(in7, OUTPUT); //Motor 4 
  pinMode(in8, OUTPUT);
  pinMode(enA, OUTPUT); //Motor 1, back right 
  pinMode(enB, OUTPUT); //Motor 2, front right 
  pinMode(enC, OUTPUT); //Motor 3, back left 
  pinMode(enD, OUTPUT); //Motor 4, front left 
}
uint32_t loopMillis =0;
void loop() {
  run_Location();
  //run_ObjectDetection();
  for(int i = 0; i<1; i++){ 
    /*turn right until right ultrasonic is on wall 
    backup until back ultra is on wall 
    forward until front ultra is on wall*/ 
    robot_rev(false, 914); 
    robot_fwd(false, 914); 
    /*left until moved length of robot 
    back until back ultra is on wall*/ 
    crab_walk_left(559); 
    robot_fwd(true, 0);
    robot_rev(false, 559); 
    /*left length of robot 
    forward until front ultra is on wall*/ 
    crab_walk_left(254); 
    robot_rev(true, 0);
    robot_fwd(false, 254); 

    /*left until left ultra on the wall 
    back until back ultra on the wall*/ 
    crab_walk_left(20);
    robot_fwd(false, 20); 
    robot_rev(true, 0); 
    motor_stop(); 
  } 
}


void run_Location(){
  u32_currentMillis = millis();
  if((u32_currentMillis - u32_positionMillis) > 60){
    u32_positionMillis = u32_currentMillis;
    packet.locationFront = ultrasonicFront.MeasureInMillimeters();
    packet.locationBack = ultrasonicBack.MeasureInMillimeters();
    packet.locationRight = ultrasonicRight.MeasureInMillimeters();
    packet.locationLeft = ultrasonicLeft.MeasureInMillimeters();
  }
}
void run_ObjectDetection(){
  // Read the data from the sensors using a 'for' loop:
  for (int i = 0; i < COUNT_SENSORS; i++) {
    objectDetectRanges_mm[i] = sensors[i].psensor->readRange();  // This is where the sensor's data is captured
    packet.objectDetectionSensors[i] = objectDetectRanges_mm[i];
  }
}

/*
*Function Name: initialize_ObjDetectSensors
*Parameters: None
*Returns: void
*Description: Initialize the Object Detection Sensors
*/

void initialize_ObjDetectSensors(){
  bool found_any_sensors = false;
  // Set all shutdown pins low to shutdown sensors
  for (int i = 0; i < COUNT_SENSORS; i++)
    digitalWrite(sensors[i].shutdown_pin, LOW);
  delay(10);

  for (int i = 0; i < COUNT_SENSORS; i++) {
    // one by one enable sensors and set their ID
    digitalWrite(sensors[i].shutdown_pin, HIGH);
    delay(10); // give time to wake up.
    if (sensors[i].psensor->begin(sensors[i].id, false, sensors[i].pwire,
                                  sensors[i].sensor_config)) {
      found_any_sensors = true;
    }
  }

}

/*
*Function Name: setup_ObjectDetection
*Parameters: None
*Returns: void
*Description: Setup the ObjDetect Sensors by Shutdown Pins 
*  then using initialize function
*/

void setup_ObjectDetection(){
  for (int i = 0; i < COUNT_SENSORS; i++) {
    pinMode(sensors[i].shutdown_pin, OUTPUT);
    digitalWrite(sensors[i].shutdown_pin, LOW);
  }
  initialize_ObjDetectSensors();

}
void Update_sensors(){ 

  if(ultrasonicFront.MeasureInMillimeters() < 50){ 

    FrontFlag = true; 

  } 
  else{ 

    FrontFlag = false; 

  } 

  if(ultrasonicBack.MeasureInMillimeters() < 50){ 

    BackFlag = true; 

  } 
  else{ 

    BackFlag = false; 

  } 

 

  if(ultrasonicRight.MeasureInMillimeters() < 50){ 

    RightFlag = true; 

  }
  else{ 

    RightFlag = false; 

  } 
} 

 

void motor_stop() {  
    digitalWrite(in1, LOW); //M1, back right  
    digitalWrite(in2, LOW);   
    digitalWrite(in3, LOW); //M2, front right  
    digitalWrite(in4, LOW);   
    digitalWrite(in5, LOW); //M3, back left  
    digitalWrite(in6, LOW);   
    digitalWrite(in7, LOW); //M4, front left  
    digitalWrite(in8, LOW);

    delay(250); 

}  

 

void robot_fwd(bool useTime, int distance) {  
  if(useTime){
    digitalWrite(in1, HIGH); //M1, back right  
    digitalWrite(in2, LOW);   
    digitalWrite(in3, LOW); //M2, front right  
    digitalWrite(in4, HIGH);   
    digitalWrite(in5, LOW); //M3, back left  
    digitalWrite(in6, HIGH);   
    digitalWrite(in7, HIGH); //M4, front left  
    digitalWrite(in8, LOW);  
    analogWrite(enB, 200);  
    analogWrite(enD, 200);  
    analogWrite(enA, 200);  
    analogWrite(enC, 200);  
    delay(500);
  }
  else{
    Update_sensors();  
    while(FrontFlag == false){  
      /*if(ultrasonicLeft.MeasureInMillimeters() > (distance + 20)){
        digitalWrite(in1, LOW); //M1, back right  
        digitalWrite(in2, HIGH);   
        digitalWrite(in3, LOW); //M2, front right  
        digitalWrite(in4, HIGH);   
        digitalWrite(in5, LOW); //M3, back left  
        digitalWrite(in6, HIGH);   
        digitalWrite(in7, LOW); //M4, front left  
        digitalWrite(in8, HIGH);  

        analogWrite(enD, 100);  
        analogWrite(enB, 110);  
        analogWrite(enC, 110);  
        analogWrite(enA, 100); 
      }
      else if(ultrasonicLeft.MeasureInMillimeters() < (distance - 20)){
        digitalWrite(in1, HIGH); //M1, back right  
        digitalWrite(in2, LOW);   
        digitalWrite(in3, HIGH); //M2, front right  
        digitalWrite(in4, LOW);   
        digitalWrite(in5, HIGH); //M3, back left  
        digitalWrite(in6, LOW);   
        digitalWrite(in7, HIGH); //M4, front left  
        digitalWrite(in8, LOW);  

        analogWrite(enD, 100);  
        analogWrite(enB, 110);  
        analogWrite(enC, 110);  
        analogWrite(enA, 100); 
      }
      else{*/
        Update_sensors(); 
        digitalWrite(in1, HIGH); //M1, back right  
        digitalWrite(in2, LOW);   
        digitalWrite(in3, LOW); //M2, front right  
        digitalWrite(in4, HIGH);   
        digitalWrite(in5, LOW); //M3, back left  
        digitalWrite(in6, HIGH);   
        digitalWrite(in7, HIGH); //M4, front left  
        digitalWrite(in8, LOW);  
        analogWrite(enB, 200);  
        analogWrite(enD, 200);  
        analogWrite(enA, 200);  
        analogWrite(enC, 200);
    } 
  }
  motor_stop(); 
}  

 

void robot_rev (bool useTime, int distance) {  
  if(useTime){
    digitalWrite(in1, LOW); //M1, back right  

    digitalWrite(in2, HIGH);   

    digitalWrite(in3, HIGH); //M2, front right  

    digitalWrite(in4, LOW);   

    digitalWrite(in5, HIGH); //M3, back left  

    digitalWrite(in6, LOW);   

    digitalWrite(in7, LOW); //M4, front left  

    digitalWrite(in8, HIGH);  

 

    analogWrite(enD, 200);  

    analogWrite(enB, 200);  

    analogWrite(enC, 200);  

    analogWrite(enA, 200);  
    delay(500);
  }
  else{
  Update_sensors();  
  while(BackFlag == false){  
    /*if(ultrasonicLeft.MeasureInMillimeters() > (distance + 20)){
        digitalWrite(in1, LOW); //M1, back right  
        digitalWrite(in2, HIGH);   
        digitalWrite(in3, LOW); //M2, front right  
        digitalWrite(in4, HIGH);   
        digitalWrite(in5, LOW); //M3, back left  
        digitalWrite(in6, HIGH);   
        digitalWrite(in7, LOW); //M4, front left  
        digitalWrite(in8, HIGH);  

        analogWrite(enD, 100);  
        analogWrite(enB, 110);  
        analogWrite(enC, 110);  
        analogWrite(enA, 100); 
      }
      else if(ultrasonicLeft.MeasureInMillimeters() < (distance - 20)){
        digitalWrite(in1, HIGH); //M1, back right  
        digitalWrite(in2, LOW);   
        digitalWrite(in3, HIGH); //M2, front right  
        digitalWrite(in4, LOW);   
        digitalWrite(in5, HIGH); //M3, back left  
        digitalWrite(in6, LOW);   
        digitalWrite(in7, HIGH); //M4, front left  
        digitalWrite(in8, LOW);  

        analogWrite(enD, 100);  
        analogWrite(enB, 110);  
        analogWrite(enC, 110);  
        analogWrite(enA, 100); 
      }
    else{*/
      Update_sensors();  

      digitalWrite(in1, LOW); //M1, back right  

      digitalWrite(in2, HIGH);   

      digitalWrite(in3, HIGH); //M2, front right  

      digitalWrite(in4, LOW);   

      digitalWrite(in5, HIGH); //M3, back left  

      digitalWrite(in6, LOW);   

      digitalWrite(in7, LOW); //M4, front left  

      digitalWrite(in8, HIGH);  

  

      analogWrite(enD, 200);  

      analogWrite(enB, 200);  

      analogWrite(enC, 210);  

      analogWrite(enA, 200);  
    } 
  }
  motor_stop(); 

}  

 

void motors_turn_right() {  

  Update_sensors();  

  while(RightFlag == false){  

    Update_sensors();  

    digitalWrite(in1, LOW); //M1, back right  

    digitalWrite(in2, HIGH);   

    digitalWrite(in3, HIGH); //M2, front right  

    digitalWrite(in4, LOW);   

    digitalWrite(in5, LOW); //M3, back left  

    digitalWrite(in6, HIGH);   

    digitalWrite(in7, HIGH); //M4, front left  

    digitalWrite(in8, LOW);  

 

    analogWrite(enD, 80);  

    analogWrite(enB, 80);  

    analogWrite(enC, 80);  

    analogWrite(enA, 80);  

  }  

  motor_stop(); 

}  

 

void crab_walk_left(int distance) {  

  //Update_sensors();  
  Serial.print("Right: ");
  Serial.println(ultrasonicRight.MeasureInMillimeters());
  Serial.print("Left: ");
  Serial.println(ultrasonicLeft.MeasureInMillimeters());
  while(ultrasonicLeft.MeasureInMillimeters() > distance){  
    Serial.println(ultrasonicLeft.MeasureInMillimeters());
    //Update_sensors();  
    digitalWrite(in1, LOW); //M1, back right  
    digitalWrite(in2, HIGH);   
    digitalWrite(in3, LOW); //M2, front right  
    digitalWrite(in4, HIGH);   
    digitalWrite(in5, LOW); //M3, back left  
    digitalWrite(in6, HIGH);   
    digitalWrite(in7, LOW); //M4, front left  
    digitalWrite(in8, HIGH);  

    analogWrite(enD, 100);  
    analogWrite(enB, 130);  
    analogWrite(enC, 130);  
    analogWrite(enA, 100);  
  }  
  motor_stop(); 

} 
