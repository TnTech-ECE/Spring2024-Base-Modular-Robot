
#include <Adafruit_Sensor_Calibration.h>
#include <Adafruit_AHRS.h>
#include <QTRSensors.h>
#include <Adafruit_VL53L0X.h>
#include <Ultrasonic.h>
#include <GyverOLED.h>
GyverOLED<SSH1106_128x64> oled;

/*
* Create accelerometer, gyroscope, magnetometer sensor values
*/
Adafruit_Sensor *accelerometer, *gyroscope, *magnetometer;

// uncomment one combo 9-DoF!
#include "LSM6DS_LIS3MDL.h"  // can adjust to LSM6DS33, LSM6DS3U, LSM6DSOX...

//Filter to convert orientation sensor data to heading, roll, pitch, etc.
Adafruit_Mahony filter;  // fastest/smalleset

#if defined(ADAFRUIT_SENSOR_CALIBRATION_USE_EEPROM)
  Adafruit_Sensor_Calibration_EEPROM cal;
#else
  Adafruit_Sensor_Calibration_SDFat cal;
#endif

#define FILTER_UPDATE_RATE_HZ 100
#define PRINT_EVERY_N_UPDATES 10


const uint8_t techLogo [] PROGMEM = {
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0xFC, 0xFC, 0xFC, 0xFC, 0x7C, 0x3C, 0x7C, 0xFC, 0x3C, 0x1C, 0xFC, 0xFC, 0xFC,
0xFC, 0xFC, 0xFC, 0xFC, 0xFC, 0x1C, 0x3C, 0xFC, 0x7C, 0x3C, 0x7C, 0xFC, 0xFC, 0xFC, 0xFC, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x1F, 0x1F, 0x1F, 0x07, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0xFF, 0xFF, 0xFF,
0x7F, 0x7F, 0xFF, 0xFF, 0xFF, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x07, 0x1F, 0x1F, 0x1F, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x07, 0x38, 0xC0, 0x00, 0x00, 0x00, 0x00, 0x0F, 0x01, 0x00,
0x00, 0x00, 0x04, 0x0E, 0x07, 0x00, 0x00, 0x00, 0x00, 0xC0, 0x38, 0x07, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xF0, 0xF0, 0xF1, 0xE3, 0xF7, 0xFC, 0xF0, 0xE0, 0xC0,
0xC0, 0xC0, 0xC0, 0xE0, 0xF0, 0xFC, 0xF7, 0xE3, 0xF1, 0xF0, 0xF0, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
};

uint32_t timestamp;
uint32_t u32_currentMillis = 0;
uint32_t u32_positionMillis = 0;
uint32_t u32_orientationMillis = 0;
uint32_t u32_locationMillis = 0;
uint32_t u32_objectDetectionMillis = 0;

QTRSensors qtr;
Adafruit_VL53L0X sensor1; //CHANGE
Adafruit_VL53L0X sensor2; //CHANGE
Adafruit_VL53L0X sensor3; //CHANGE
Adafruit_VL53L0X sensor4; //CHANGE
Adafruit_VL53L0X sensor5; //CHANGE
Adafruit_VL53L0X sensor6; //CHANGE
Adafruit_VL53L0X sensor7; //CHANGE
Adafruit_VL53L0X sensor8; //CHANGE

uint32_t u32_LineFollowingTime = 0;

const uint8_t SensorCount = 6;
uint16_t sensorValues[SensorCount];
sensors_event_t accel, gyro, mag;
String start = "<";
String end = ">";
String c = ",";

typedef struct {
  Adafruit_VL53L0X *psensor; // pointer to object
  TwoWire *pwire;
  int id;            // IIC id number for the sensor
  int shutdown_pin;  // which pin for shutdown;
  int interrupt_pin; // which pin to use for interrupts.
  Adafruit_VL53L0X::VL53L0X_Sense_config_t sensor_config; // options for how to use the sensor
  uint16_t range;        // range value used in continuous mode stuff.
  uint8_t sensor_status; // status from last ranging in continuous.
} sensorList_t;


// Setup for 8 sensors by defining information for each sensor in a 'sensors' array. Include
// a separate line of information for each sensor
sensorList_t sensors[] = {
  // For 'sensor1', define the IIC accress as hexadecimal value 0x30. Assign digital pin #38 to this 
  // sensor's XSHUT pin (shut-down pin). Assign digital pin #5 to the sensor's INTERRUPT pin.
  {&sensor1, &Wire, 0x30, 38, 5, Adafruit_VL53L0X::VL53L0X_SENSE_DEFAULT, 0, 0},

  // For 'sensor2', define the IIC accress as hexadecimal value 0x31. Assign digital pin #6 to this 
  // sensor's XSHUT pin (shut-down pin). Assign digital pin #7 to the sensor's INTERRUPT pin.
  {&sensor2, &Wire, 0x31, 6, 7, Adafruit_VL53L0X::VL53L0X_SENSE_DEFAULT, 0, 0},

  
  // For 'sensor3', define the IIC accress as hexadecimal value 0x32. Assign digital pin #40 to this 
  // sensor's XSHUT pin (shut-down pin). Assign digital pin #3 to the sensor's INTERRUPT pin.
  {&sensor3, &Wire, 0x32, 40, 3, Adafruit_VL53L0X::VL53L0X_SENSE_DEFAULT, 0, 0},
  
  // For 'sensor4', define the IIC accress as hexadecimal value 0x33. Assign digital pin #29 to this 
  // sensor's XSHUT pin (shut-down pin). Assign digital pin #30 to the sensor's INTERRUPT pin.
  {&sensor4, &Wire, 0x33, 29, 30, Adafruit_VL53L0X::VL53L0X_SENSE_DEFAULT, 0, 0},

  // For 'sensor5', define the IIC accress as hexadecimal value 0x34. Assign digital pin #31 to this 
  // sensor's XSHUT pin (shut-down pin). Assign digital pin #32 to the sensor's INTERRUPT pin.
  {&sensor5, &Wire, 0x34, 31, 32, Adafruit_VL53L0X::VL53L0X_SENSE_DEFAULT, 0, 0},

  // For 'sensor6', define the IIC accress as hexadecimal value 0x35. Assign digital pin #33 to this 
  // sensor's XSHUT pin (shut-down pin). Assign digital pin #34 to the sensor's INTERRUPT pin.
  {&sensor6, &Wire, 0x35, 33, 34, Adafruit_VL53L0X::VL53L0X_SENSE_DEFAULT, 0, 0},

  // For 'sensor7', define the IIC accress as hexadecimal value 0x36. Assign digital pin #35 to this 
  // sensor's XSHUT pin (shut-down pin). Assign digital pin #36 to the sensor's INTERRUPT pin.
  {&sensor7, &Wire, 0x36, 35, 36, Adafruit_VL53L0X::VL53L0X_SENSE_DEFAULT, 0, 0},
  
  // For 'sensor8', define the IIC accress as hexadecimal value 0x37. Assign digital pin #37 to this 
  // sensor's XSHUT pin (shut-down pin). Assign digital pin #38 to the sensor's INTERRUPT pin.
  {&sensor8, &Wire, 0x37, 37, 38, Adafruit_VL53L0X::VL53L0X_SENSE_DEFAULT, 0, 0}
  
};
const int COUNT_SENSORS = sizeof(sensors) / sizeof(sensors[0]); //CHANGE
uint16_t objectDetectRanges_mm[COUNT_SENSORS]; //CHANGE
struct Packet{
  uint16_t lineFollowing;
  uint32_t locationFront; //CHANGE
  uint32_t locationBack; //CHANGE
  uint32_t locationRight; //CHANGE
  uint32_t locationLeft; //CHANGE
  uint16_t objectDetectionSensors[8]; //CHANGE
  float heading;
  float roll;
  float pitch;
  float qw;
  float qx;
  float qy; 
  float qz;
};

Packet packet;
void run_Orientation();
void run_LineFollowing();
void run_Location();
void run_ObjectDetection();
void setup_ObjectDetection();
void initialize_ObjDetectSensors();

Ultrasonic ultrasonicFront(8); //CHANGE
Ultrasonic ultrasonicBack(9); //CHANGE
Ultrasonic ultrasonicRight(10); //CHANGE
Ultrasonic ultrasonicLeft(11); //CHANGE


void setup() {
  Serial.begin(115200);
  delay(200);
  oled.init();             
  oled.clear();
  setup_ObjectDetection();
  if (!cal.begin()) {
  } else if (! cal.loadCalibration()) {
  }
  if (!init_sensors()) {
  }

  setup_sensors();
  filter.begin(FILTER_UPDATE_RATE_HZ);
  timestamp = millis();
  
  Wire.begin();
  Wire.setClock(400000); // 400KHz

  cal.calibrate(mag);
  cal.calibrate(accel);
  cal.calibrate(gyro);

  qtr.setTypeRC();
  qtr.setSensorPins((const uint8_t[]){28, 27, 26, 25, 24, 23}, SensorCount);
  qtr.setEmitterPin(22);

  /*
  qtr_back.setTypeRC();
  qtr_back.setSensorPins((const uint8_t[]){48, 49, 50 , 51, 52, 53}, SensorCount);
  qtr_back.setEmitterPin(47);*/


  delay(500);
  pinMode(LED_BUILTIN, OUTPUT);
  digitalWrite(LED_BUILTIN, HIGH); // turn on Arduino's LED to indicate we are in calibration mode
  for (uint16_t i = 0; i < 400; i++)
  {
    qtr.calibrate();
  }
  digitalWrite(LED_BUILTIN, LOW); // turn off Arduino's LED to indicate we are through with calibration
  delay(2000);

}
uint32_t loopMillis =0;
void loop() {
  run_Orientation();
  run_LineFollowing();
  run_Location();
  run_ObjectDetection();
  if((millis() - loopMillis) > 3000){
    loopMillis = millis();
    oled.drawBitmap(0, 0, techLogo, 128, 64);
    oled.update();
  }
  Serial.println(start + packet.lineFollowing + c + packet.heading + c + packet.roll + c + packet.pitch + c + packet.qw + c + packet.qx + c + packet.qy + c + packet.qz + c + packet.locationFront + c + packet.locationRight + c + packet.locationBack + c + packet.locationLeft + c + packet.objectDetectionSensors[0] + c + packet.objectDetectionSensors[1] + c + packet.objectDetectionSensors[2] + c + packet.objectDetectionSensors[3] + c + packet.objectDetectionSensors[4] + c + packet.objectDetectionSensors[5] + c + packet.objectDetectionSensors[6] + c + packet.objectDetectionSensors[7]  + end);
}
void run_Orientation(){
  float roll, pitch, heading;
  float gx, gy, gz;
  
    timestamp = millis();
    // Read the motion sensors
    accelerometer->getEvent(&accel);
    gyroscope->getEvent(&gyro);
    magnetometer->getEvent(&mag);

    // Gyroscope needs to be converted from Rad/s to Degree/s
    // the rest are not unit-important
    gx = gyro.gyro.x * SENSORS_RADS_TO_DPS;
    gy = gyro.gyro.y * SENSORS_RADS_TO_DPS;
    gz = gyro.gyro.z * SENSORS_RADS_TO_DPS;

    // Update the SensorFusion filter
    filter.update(gx, gy, gz, 
                  accel.acceleration.x, accel.acceleration.y, accel.acceleration.z, 
                  mag.magnetic.x, mag.magnetic.y, mag.magnetic.z);

    // print the heading, pitch and roll
    roll = filter.getRoll();
    pitch = filter.getPitch();
    heading = filter.getYaw();
    packet.heading = heading;
    packet.pitch = pitch;
    packet.roll = roll;

    float qw, qx, qy, qz;
    filter.getQuaternion(&qw, &qx, &qy, &qz);
    packet.qw = qw;

    packet.qx = qx;

    packet.qy = qy;

    packet.qz = qz;
}
void run_LineFollowing(){
  u32_currentMillis = millis();
  if((u32_currentMillis - u32_LineFollowingTime)>=250){
    uint16_t position = qtr.readLineBlack(sensorValues);
    // print the sensor values as numbers from 0 to 1000, where 0 means maximum
    // reflectance and 1000 means minimum reflectance, followed by the line
    // position
    /*for (uint8_t i = 0; i < SensorCount; i++)
    {
      Serial.print(sensorValues[i]);
      Serial.print('\t');
    }*/
    packet.lineFollowing = position; 
  }
}
void run_Location(){
  u32_currentMillis = millis();
  if((u32_currentMillis - u32_positionMillis) > 60){
    u32_positionMillis = u32_currentMillis;
    packet.locationFront = ultrasonicFront.MeasureInMillimeters();
    packet.locationBack = ultrasonicBack.MeasureInMillimeters();
    packet.locationRight = ultrasonicRight.MeasureInMillimeters();
    packet.locationLeft = ultrasonicLeft.MeasureInMillimeters();
  }
}
void run_ObjectDetection(){
  // Read the data from the sensors using a 'for' loop:
  for (int i = 0; i < COUNT_SENSORS; i++) {
    objectDetectRanges_mm[i] = sensors[i].psensor->readRange();  // This is where the sensor's data is captured
    packet.objectDetectionSensors[i] = objectDetectRanges_mm[i];
  }
}

/*
*Function Name: initialize_ObjDetectSensors
*Parameters: None
*Returns: void
*Description: Initialize the Object Detection Sensors
*/

void initialize_ObjDetectSensors(){
  bool found_any_sensors = false;
  // Set all shutdown pins low to shutdown sensors
  for (int i = 0; i < COUNT_SENSORS; i++)
    digitalWrite(sensors[i].shutdown_pin, LOW);
  delay(10);

  for (int i = 0; i < COUNT_SENSORS; i++) {
    // one by one enable sensors and set their ID
    digitalWrite(sensors[i].shutdown_pin, HIGH);
    delay(10); // give time to wake up.
    if (sensors[i].psensor->begin(sensors[i].id, false, sensors[i].pwire,
                                  sensors[i].sensor_config)) {
      found_any_sensors = true;
    }
  }

}

/*
*Function Name: setup_ObjectDetection
*Parameters: None
*Returns: void
*Description: Setup the ObjDetect Sensors by Shutdown Pins 
*  then using initialize function
*/

void setup_ObjectDetection(){
  for (int i = 0; i < COUNT_SENSORS; i++) {
    pinMode(sensors[i].shutdown_pin, OUTPUT);
    digitalWrite(sensors[i].shutdown_pin, LOW);
  }
  initialize_ObjDetectSensors();

}
